<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Manga Manager Prototype</title>
    <link rel="stylesheet" href="style.css">
    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="icon.svg">
    <meta name="theme-color" content="#6200ee">
    <script>
        // Emergency Inline Script for Settings & Manual Add
        // This ensures these functions exist even if app.js fails to load or update immediately.

        // --- Standalone State Management ---
        function ensureState() {
            if (!window.state) {
                try {
                    const raw = localStorage.getItem('manga_manager_data');
                    if (raw) {
                        window.state = JSON.parse(raw);
                    } else {
                        // Default Data
                        window.state = {
                            unpurchased: [],
                            purchased: [],
                            settings: { autoDeletePeriod: '30' },
                            publishers: [
                                { id: 'shueisha', name: '集英社', short: 'S', color: '#e50012' },
                                { id: 'kodansha', name: '講談社', short: 'K', color: '#0097a7' },
                                { id: 'shogakukan', name: '小学館', short: 'Sk', color: '#ffeb3b', textColor: 'black' },
                                { id: 'kadokawa', name: 'KADOKAWA', short: 'Kd', color: '#1a237e' }
                            ]
                        };
                        saveStateLocal();
                    }
                } catch (e) {
                    window.state = { unpurchased: [], purchased: [], settings: {}, publishers: [] };
                }
            }
            // Ensure arrays exist
            if (!window.state.unpurchased) window.state.unpurchased = [];
            if (!window.state.purchased) window.state.purchased = [];
            if (!window.state.publishers || window.state.publishers.length === 0) {
                window.state.publishers = [
                    { id: 'shueisha', name: '集英社', short: 'S', color: '#e50012' },
                    { id: 'kodansha', name: '講談社', short: 'K', color: '#0097a7' },
                    { id: 'shogakukan', name: '小学館', short: 'Sk', color: '#ffeb3b', textColor: 'black' },
                    { id: 'kadokawa', name: 'KADOKAWA', short: 'Kd', color: '#1a237e' }
                ];
            }
        }

        // --- Publisher Helpers ---
        // --- Publisher Helpers ---
        function generatePublisherOptions(selectedId) {
            ensureState();
            // Defaults to first publisher if no selection, unless it's "add-new"
            const defaultId = (window.state.publishers[0] && window.state.publishers[0].id) || '';
            let targetId = selectedId;
            if (!targetId || targetId === 'other') targetId = defaultId;

            let html = window.state.publishers.map(p =>
                `<option value="${p.id}" ${p.id === targetId ? 'selected' : ''}>${p.name}</option>`
            ).join('');

            // ADD 'Add New' option
            html += `<option value="add-new">+ 出版社を追加...</option>`;
            return html;
        }

        function checkPublisherSelect(selectEl) {
            if (selectEl.value === 'add-new') {
                // Determine which screen we are in to know where to return or how to update
                // For now, we update all selectors after adding.
                window.publisherSelectTarget = selectEl;
                openPublisherModal();
                // Temporarily reset to index 0 to avoid sticking on "add-new" visually if cancelled
                if (window.state.publishers.length > 0) {
                    selectEl.value = window.state.publishers[0].id;
                }
            }
        }

        // --- Standalone Helper: Save ---
        function saveStateLocal() {
            if (window.saveState) {
                window.saveState();
            } else {
                try {
                    localStorage.setItem('manga_manager_data', JSON.stringify(window.state));
                } catch (e) { console.error('Local Save Failed', e); }
            }
        }

        // --- Standalone Helper: Render (FORCED) ---
        function renderHomeLocal() {
            console.log('Forcing Local Render v24');

            // 1. Render Unpurchased
            const listUn = document.getElementById('list-unpurchased');
            if (listUn) {
                listUn.innerHTML = '';
                if (!window.state || !window.state.unpurchased || window.state.unpurchased.length === 0) {
                    listUn.innerHTML = '<div class="empty-state">未購入のマンガはありません</div>';
                } else {
                    // Sort by updated desc (newest first)
                    const sorted = [...window.state.unpurchased].sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
                    sorted.forEach(item => {
                        listUn.appendChild(createCardLocal(item, 'unpurchased'));
                    });
                }
            }

            // 2. Render Purchased
            const listPur = document.getElementById('list-purchased');
            if (listPur) {
                listPur.innerHTML = '';
                if (!window.state || !window.state.purchased || window.state.purchased.length === 0) {
                    listPur.innerHTML = '<div class="empty-state">購入済みのマンガはありません</div>';
                } else {
                    // Sort by updated time desc
                    const sorted = [...window.state.purchased].sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
                    sorted.forEach(item => {
                        listPur.appendChild(createCardLocal(item, 'purchased'));
                    });
                }
            }
        }

        function createCardLocal(item, status) {
            const el = document.createElement('div');
            el.className = 'card';
            el.style.borderLeft = `4px solid ${getPubColor(item.publisher)}`;

            const isPurchased = status === 'purchased';
            const checkIcon = isPurchased ? 'check' : '';
            const checkClass = isPurchased ? 'checked' : '';

            // Checkbox HTML
            // We use onclick="event.stopPropagation(); toggleStatusLocal(...)" to avoid triggering card edit
            const checkboxHtml = `
                <div class="checkbox ${checkClass}" onclick="event.stopPropagation(); toggleStatusLocal('${item.id}', '${status}')">
                    ${isPurchased ? '<span class="material-icons" style="font-size:16px; color:white;">check</span>' : ''}
                </div>
            `;

            el.innerHTML = `
                <div class="card-info" onclick="openManualEditFallback('${item.id}')">
                    <div class="card-title">
                        <span style="font-size:12px; color:#666; margin-right:4px;">[${getPubShort(item.publisher)}]</span>
                        ${item.title}
                    </div>
                    <span class="card-vol">${item.volume}巻</span>
                </div>
                <div class="card-actions">
                    ${checkboxHtml}
                </div>
            `;
            return el;
        }

        function toggleStatusLocal(id, currentStatus) {
            ensureState();
            const sourceList = currentStatus === 'unpurchased' ? window.state.unpurchased : window.state.purchased;
            const targetList = currentStatus === 'unpurchased' ? window.state.purchased : window.state.unpurchased;

            const idx = sourceList.findIndex(x => x.id === id);
            if (idx > -1) {
                const item = sourceList.splice(idx, 1)[0];
                item.status = currentStatus === 'unpurchased' ? 'purchased' : 'unpurchased';
                item.updatedAt = Date.now();

                // Add to TOP of target list
                targetList.unshift(item);

                saveStateLocal();
                renderHomeLocal();
                showToast(item.status === 'purchased' ? '購入済みにしました' : '未購入に戻しました');
            }
        }

        function toggleTab(tabName) {
            // Update Tab Buttons
            document.querySelectorAll('.tab').forEach(t => {
                if (t.dataset.tab === tabName) t.classList.add('active');
                else t.classList.remove('active');
            });

            // Update Lists
            const listUn = document.getElementById('list-unpurchased');
            const listPur = document.getElementById('list-purchased');

            if (tabName === 'unpurchased') {
                if (listUn) listUn.classList.remove('hidden');
                if (listPur) listPur.classList.add('hidden');
            } else {
                if (listUn) listUn.classList.add('hidden');
                if (listPur) listPur.classList.remove('hidden');
            }
        }


        function openManualEditFallback(id) {
            // Basic edit fallback
            window.currentDetailId = id;
            navigateToScreen('screen-detail-edit');
            // Populate basics
            ensureState();
            const item = window.state.unpurchased.find(i => i.id === id);
            if (item) {
                document.getElementById('detail-title').value = item.title;
                document.getElementById('detail-volume').value = item.volume;
            }
        }

        function openManualAdd() {
            ensureState();

            // Reset Detail ID
            if (window.appState) window.appState.currentDetailId = null;
            window.currentDetailId = null;

            // Reset Form
            const titleInput = document.getElementById('detail-title');
            const volInput = document.getElementById('detail-volume');
            if (titleInput) titleInput.value = '';
            if (volInput) volInput.value = '';

            // Publisher Reset
            const pubSelect = document.getElementById('detail-publisher');
            if (pubSelect && window.state.publishers.length > 0) {
                const defaultPub = window.state.publishers[0].id; // Default to first (e.g., Shueisha)
                pubSelect.innerHTML = generatePublisherOptions(defaultPub);
                pubSelect.value = defaultPub;
            }

            // Adjust UI
            const pTitle = document.getElementById('page-title');
            if (pTitle) pTitle.textContent = 'マンガを手動追加';

            const btnDel = document.getElementById('btn-delete-item');
            if (btnDel) btnDel.classList.add('hidden');

            const btnReason = document.getElementById('btn-detail-reason');
            if (btnReason) btnReason.classList.add('hidden');

            navigateToScreen('screen-detail-edit');
        }

        function closeDetailEdit() {
            navigateToScreen('screen-home');
        }

        function saveDetailItem() {
            try {
                ensureState(); // Ensure state exists

                const titleInput = document.getElementById('detail-title');
                const title = titleInput ? titleInput.value.trim() : '';

                if (!title) {
                    alert('タイトルを入力してください');
                    return;
                }

                const volume = document.getElementById('detail-volume').value;
                let publisher = document.getElementById('detail-publisher').value;

                // Handle "add-new" being selected by accident or bug
                if (publisher === 'add-new' || !publisher) {
                    if (window.state.publishers.length > 0) {
                        publisher = window.state.publishers[0].id;
                    } else {
                        publisher = 'shueisha'; // Fallback
                    }
                }

                if (window.currentDetailId) {
                    // Update
                    let item = window.state.unpurchased.find(i => i.id === window.currentDetailId);
                    if (!item) item = window.state.purchased.find(i => i.id === window.currentDetailId);

                    if (item) {
                        item.title = title;
                        item.volume = volume;
                        item.publisher = publisher;
                        showToast('保存しました');
                    }
                } else {
                    // Create New
                    const newItem = {
                        id: Date.now().toString(),
                        title: title,
                        volume: volume,
                        publisher: publisher,
                        status: 'unpurchased',
                        reason: null,
                        updatedAt: Date.now()
                    };
                    window.state.unpurchased.unshift(newItem); // Add to top
                    showToast('追加しました(未購入)');
                }

                saveStateLocal();

                // Clear Search/Filter
                const sText = document.getElementById('search-text');
                if (sText) sText.value = '';

                // Enable Unpurchased Tab to make sure user sees the item
                toggleTab('unpurchased');
                renderHomeLocal(); // FORCE LOCAL RENDER

                closeDetailEdit();
            } catch (e) {
                console.error(e);
                alert('エラーが発生しました: ' + e.message);
            }
        }

        // Force Reset Function
        function hardResetApp() {
            if (!confirm('アプリを初期化して再読み込みしますか？(データは維持されます)')) return;

            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(function (registrations) {
                    for (let registration of registrations) {
                        registration.unregister();
                    }
                    window.location.reload(true);
                });
            } else {
                window.location.reload(true);
            }
        }

        // Initial Render
        window.addEventListener('load', () => { setTimeout(renderHomeLocal, 500); });

        function navigateToScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const target = document.getElementById(screenId);
            if (target) target.classList.add('active');

            const header = document.querySelector('header');
            if (header) {
                if (screenId === 'screen-edit') {
                    header.classList.add('hidden');
                } else {
                    header.classList.remove('hidden');
                }
            }

            const pTitle = document.getElementById('page-title');
            if (screenId === 'screen-home' && pTitle) {
                pTitle.textContent = 'Manga Manager';
            }
        }

        function openSettings() {
            const modal = document.getElementById('modal-settings');
            if (modal) modal.classList.remove('hidden');

            try {
                const autoDelete = document.getElementById('setting-auto-delete');
                if (autoDelete && window.state && window.state.settings) {
                    autoDelete.value = window.state.settings.autoDeletePeriod || '30';
                }
                if (window.forceRenderPublishers) window.forceRenderPublishers();
            } catch (e) { console.error(e); }
        }

        function closeSettings() {
            document.getElementById('modal-settings').classList.add('hidden');
        }

        function saveSettings() {
            try {
                const autoDelete = document.getElementById('setting-auto-delete');
                if (autoDelete && window.state && window.state.settings) {
                    window.state.settings.autoDeletePeriod = autoDelete.value;
                    saveStateLocal();
                    if (window.checkAutoDelete) window.checkAutoDelete();
                }
                closeSettings();
                showToast('設定を保存しました');
            } catch (e) {
                alert('エラー: 設定を保存できませんでした。アプリをリロードしてください。');
            }
        }

        // --- Publisher Management Helpers ---
        function forceRenderPublishers() {
            ensureState();
            const container = document.getElementById('settings-publisher-list');
            if (!container) return;

            container.innerHTML = '';
            window.state.publishers.forEach((p, index) => {
                // Don't allow deleting the default 4 if you want to protect them, or allow all.
                // Let's allow deleting custom ones, but maybe protect the big 4? 
                // For now, simple implementation:
                const div = document.createElement('div');
                div.style.display = 'flex';
                div.style.justifyContent = 'space-between';
                div.style.padding = '4px';
                div.style.borderBottom = '1px solid #eee';

                div.innerHTML = `
                    <span>${p.name}</span>
                    <button onclick="deletePublisher('${p.id}')" style="color:red; border:none; background:none;">×</button>
                 `;
                container.appendChild(div);
            });

            // Add "Add" button at bottom
            const addBtn = document.createElement('div');
            addBtn.innerHTML = `<button onclick="openPublisherModal()" style="width:100%; margin-top:8px; color:var(--primary-color); border:1px dashed var(--primary-color); background:none; padding:4px;">+ 追加</button>`;
            container.appendChild(addBtn);
        }

        function deletePublisher(id) {
            if (!confirm('この出版社を削除しますか？')) return;
            ensureState();
            const idx = window.state.publishers.findIndex(p => p.id === id);
            if (idx > -1) {
                window.state.publishers.splice(idx, 1);
                saveStateLocal();
                forceRenderPublishers();
                // Refresh dropdown in Filter
                const fPub = document.getElementById('filter-publisher');
                if (fPub) {
                    const currentVal = fPub.value;
                    let html = '<option value="all">全出版社</option>';
                    html += window.state.publishers.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
                    fPub.innerHTML = html;
                    fPub.value = currentVal;
                }
            }
        }

        function openPublisherModal() {
            const m = document.getElementById('modal-publisher');
            if (m) m.classList.remove('hidden');
        }

        document.getElementById('btn-close-pub-modal').onclick = function () {
            document.getElementById('modal-publisher').classList.add('hidden');
        };

        document.getElementById('btn-save-publisher').onclick = function () {
            const nameInput = document.getElementById('new-publisher-name');
            const name = nameInput.value.trim();
            if (!name) return;

            ensureState();
            const newId = 'pub_' + Date.now();
            window.state.publishers.push({
                id: newId,
                name: name,
                short: name.substring(0, 2),
                color: '#888888' // Default gray
            });

            saveStateLocal();
            nameInput.value = '';
            document.getElementById('modal-publisher').classList.add('hidden');

            forceRenderPublishers(); // Refresh settings list

            // Refresh manual add dropdown if open
            if (window.publisherSelectTarget) {
                window.publisherSelectTarget.innerHTML = generatePublisherOptions(newId);
                window.publisherSelectTarget.value = newId;
                window.publisherSelectTarget = null;
            } else {
                // Try to refresh just in case
                const manualSelect = document.getElementById('detail-publisher');
                if (manualSelect) {
                    const curr = manualSelect.value;
                    manualSelect.innerHTML = generatePublisherOptions(curr);
                    manualSelect.value = curr;
                }
            }

            showToast('出版社を追加しました');
        };

        function deleteAllPurchased() {
            if (!confirm('本当に全ての購入済みデータを削除しますか？')) return;
            try {
                ensureState();
                window.state.purchased = [];
                saveStateLocal();
                renderHomeLocal();

                closeSettings();
                showToast('削除しました');
            } catch (e) {
                console.error(e);
            }
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.remove('hidden');
            setTimeout(() => { toast.classList.add('hidden'); }, 3000);
        }

        // --- Camera Logic ---
        let videoStream = null;

        function openCamera() {
            navigateToScreen('screen-camera');
            startCamera();
        }

        function closeCamera() {
            stopCamera();
            navigateToScreen('screen-home');
        }

        async function startCamera() {
            const videoEl = document.getElementById('camera-feed');
            if (!videoEl) return;

            try {
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' },
                    audio: false
                });
                videoEl.srcObject = videoStream;
            } catch (err) {
                console.error("Camera Error:", err);
                alert('カメラを起動できませんでした。\nブラウザの権限設定を確認してください。');
                closeCamera();
            }
        }

        function stopCamera() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
        }

        function takePicture() {
            // Visual feedback
            const btn = document.getElementById('btn-shutter');
            if (btn) btn.style.backgroundColor = 'red';

            setTimeout(() => {
                if (btn) btn.style.backgroundColor = 'white';
                stopCamera();

                // MOCK OCR: Add a dummy item for now
                ensureState();
                const newItem = {
                    id: Date.now().toString(),
                    title: '撮影アイテム(仮)',
                    volume: '1',
                    publisher: window.state.publishers[0] ? window.state.publishers[0].id : 'shueisha',
                    status: 'unpurchased',
                    reason: null,
                    updatedAt: Date.now()
                };
                window.state.unpurchased.unshift(newItem);
                saveStateLocal();
                renderHomeLocal();

                showToast('スキャン完了: 撮影アイテム(仮)を追加しました');
                navigateToScreen('screen-home');
            }, 500);
        }
        // Service Worker Update Logic
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').then(reg => {
                reg.onupdatefound = () => {
                    const installingWorker = reg.installing;
                    installingWorker.onstatechange = () => {
                        if (installingWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            window.location.reload();
                        }
                    };
                };
            });
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                window.location.reload();
            });
        }
    </script>

<body>

    <!-- App Container -->
    <div id="app">

        <!-- Header -->
        <header>
            <h1 id="page-title">Manga Manager</h1>
            <button id="btn-settings" class="icon-btn" style="margin-left: auto; margin-right: 8px;"
                onclick="openSettings()">
                <span class="material-icons">settings</span>
            </button>
            <button id="header-action-btn" class="icon-btn hidden">
                <span class="material-icons">check</span>
            </button>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Home Screen -->
            <section id="screen-home" class="screen active">
                <div class="tabs">
                    <button class="tab active" data-tab="unpurchased" onclick="toggleTab('unpurchased')">未購入</button>
                    <button class="tab" data-tab="purchased" onclick="toggleTab('purchased')">購入済</button>
                </div>

                <div class="search-container" style="padding: 8px 16px; background: #f5f5f5; display: flex; gap: 8px;">
                    <input type="text" id="search-text" class="text-input" placeholder="タイトル検索..."
                        style="flex: 2; font-size: 14px;">
                    <select id="filter-publisher" class="text-input" style="flex: 1; font-size: 14px;">
                        <option value="all">全出版社</option>
                        <!-- Options injected by JS -->
                    </select>
                </div>

                <div id="list-unpurchased" class="comic-list">
                    <!-- Cards will be injected here -->
                </div>

                <div id="list-purchased" class="comic-list hidden">
                    <!-- Cards will be injected here -->
                </div>

                <button id="fab-add-manual" class="fab"
                    style="left: 24px; right: auto; background-color: white; color: var(--primary-color);"
                    onclick="openManualAdd()">
                    <span class="material-icons">edit</span>
                </button>

                <button id="fab-camera" class="fab" onclick="openCamera()">
                    <span class="material-icons">camera_alt</span>
                </button>
            </section>

            <!-- 2. Camera Screen -->
            <section id="screen-camera" class="screen">
                <div class="camera-view">
                    <!-- Video for Real Camera -->
                    <video id="camera-feed" autoplay playsinline
                        style="position: absolute; width: 100%; height: 100%; object-fit: cover;"></video>

                    <div class="camera-overlay">
                        <div class="guide-frame"></div>
                    </div>
                </div>
                <div class="camera-controls">
                    <button id="btn-gallery" class="icon-btn">
                        <span class="material-icons">photo_library</span>
                    </button>
                    <button id="btn-shutter" class="shutter-btn" onclick="takePicture()"></button>
                    <button id="btn-close-camera" class="icon-btn" onclick="closeCamera()">
                        <span class="material-icons">close</span>
                    </button>
                </div>
            </section>

            <!-- 3. OCR Edit Screen -->
            <section id="screen-edit" class="screen">
                <div class="edit-header-controls"
                    style="padding: 0 16px; height: 56px; display: flex; align-items: center; justify-content: space-between; background: var(--primary-color); color: white; position: sticky; top: 0; z-index: 10;">
                    <button id="btn-cancel-edit" class="icon-btn">
                        <span class="material-icons">close</span>
                    </button>
                    <span style="font-size: 20px; font-weight: 500;">読取結果確認</span>
                    <button id="btn-save-edit" class="icon-btn">
                        <span class="material-icons">check</span>
                    </button>
                </div>
                <div id="ocr-list" class="edit-list">
                    <!-- Editable Cards w/ AI suggestions injected here -->
                </div>
            </section>

            <!-- 4. Detail Edit Screen (Single Item) -->
            <section id="screen-detail-edit" class="screen">
                <div class="edit-container">
                    <div class="input-group">
                        <label class="input-label">タイトル</label>
                        <input type="text" id="detail-title" class="text-input">
                    </div>
                    <div class="input-group">
                        <label class="input-label">巻数</label>
                        <input type="number" id="detail-volume" class="text-input" style="width: 80px;">
                    </div>
                    <div class="input-group">
                        <label class="input-label">出版社</label>
                        <select id="detail-publisher" class="text-input" onchange="checkPublisherSelect(this)">
                            <!-- Options injected by JS -->
                        </select>
                    </div>

                    <div class="edit-actions" style="margin-top: 32px;">
                        <button id="btn-cancel-detail" class="btn-flat" style="margin-right: auto;"
                            onclick="closeDetailEdit()">戻る</button>
                        <button id="btn-delete-item" class="btn-flat text-danger"
                            onclick="deleteDetailItem()">削除</button>
                        <button id="btn-detail-reason" class="btn-flat text-primary"
                            onclick="openDetailReasonModal()">未購入理由...</button>
                        <button id="btn-save-detail" class="primary" style="margin-left: 8px;"
                            onclick="saveDetailItem()">保存</button>
                    </div>
                </div>
            </section>
        </main>

        <!-- Publisher Add Modal -->
        <div id="modal-publisher" class="modal hidden">
            <div class="modal-content">
                <h3 style="margin-bottom: 16px;">出版社を追加</h3>
                <input type="text" id="new-publisher-name" class="text-input" placeholder="出版社名">
                <div class="modal-actions">
                    <button id="btn-close-pub-modal" class="btn-flat">キャンセル</button>
                    <button id="btn-save-publisher" class="primary">追加</button>
                </div>
            </div>
        </div>

        <!-- Modal: Settings -->
        <div id="modal-settings" class="modal hidden">
            <div class="modal-content">
                <h3>設定</h3>

                <div class="input-group">
                    <label class="input-label">購入済みデータの自動削除</label>
                    <select id="setting-auto-delete" class="text-input">
                        <option value="never">削除しない</option>
                        <option value="3">3日後</option>
                        <option value="7">1週間後</option>
                        <option value="30">1ヶ月後</option>
                    </select>
                </div>

                <div class="input-group" style="margin-top: 20px;">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                        <label class="input-label" style="margin-bottom: 0;">出版社管理</label>
                        <button onclick="forceRenderPublishers()"
                            style="background: none; border: none; color: var(--primary-color); font-size: 12px; cursor: pointer;">更新</button>
                    </div>
                    <div id="settings-publisher-list"
                        style="max-height: 150px; overflow-y: auto; border: 1px solid #ddd; padding: 8px; border-radius: 4px; background: #fff;">
                        <!-- Publishers injected here -->
                    </div>
                </div>

                <div class="input-group" style="margin-top: 20px; border-top: 1px solid #eee; padding-top: 20px;">
                    <button id="btn-delete-all-purchased" class="btn-flat text-danger"
                        style="width: 100%; border: 1px solid #ff5252; margin-bottom: 12px;"
                        onclick="deleteAllPurchased()">
                        購入済みデータを全て削除
                    </button>
                    <button onclick="hardResetApp()" class="btn-flat"
                        style="width: 100%; color: #666; font-size: 12px;">
                        アプリを初期化 (リロード)
                    </button>
                </div>

                <div class="modal-actions">
                    <button id="btn-close-settings" onclick="closeSettings()">閉じる</button>
                    <button id="btn-save-settings" class="primary" onclick="saveSettings()">保存</button>
                </div>
            </div>
        </div>

        <!-- Toast Notification -->
        <div id="toast" class="toast hidden">Message</div>

    </div>

    <!-- 
         DISABLED APP.JS to resolve conflict. 
         All logic is now inside index.html for stability. 
         <script src="app.js"></script> 
    -->
</body>

</html>